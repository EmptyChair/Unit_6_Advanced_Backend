## Theory

### Lesson 1: План
1. Понятие многопоточности.
2. Способы создания потоков. Thread и Runnable.
3. Проблемы многопоточности и способы их решения.

### Lesson 1: Theory
* Процессы и потоки
    - Определение и различие между процессом и потоком.
    - Процессы как независимые единицы с собственными ресурсами.
    - Потоки как подзадачи внутри процесса, использующие общие ресурсы.
    - Разница между потоками и процессами в контексте информации, использования памяти и скорости переключения.

* Задача-визуализация: разгрузка товара из грузовика рабочими
  - Проблемы: 
    - неизвестна наперёд скорость выполнения отдельными рабочими 
    - разделение задач между рабочими
  - слишком много потоков - тоже плохо, поскольку сам поток требует ресурсов. Соответственно надо взвесить соотношение выигрыш от ускорения и проигрыш от создания потока
  - факторов, влияющих на скорость - много, сложно предугадать результат

* Управление потоками:
  - Метод start() запускает поток, в то время как вызов run() просто выполняет код в текущем потоке.
  - Можно устанавливать приоритеты потоков, используя метод setPriority(), что влияет на распределение времени процессора между потоками.
  - Потоки-демоны (daemon threads) — это служебные потоки, которые не препятствуют завершению работы JVM.
  - Метод join() позволяет одному потоку ожидать завершения работы другого потока.
  - Приостановка выполнения потока может быть реализована с помощью Thread.sleep()

* Метод join():
  - Метод join() в Java позволяет одному потоку ожидать завершения другого потока
  - Это особенно полезно в многопоточных программах, где один поток должен дождаться завершения других потоков перед продолжением выполнения. 
  - Этот метод блокирует текущий поток до тех пор, пока целевой поток, на котором был вызван join(), не завершится.

* Проблемы многопоточности:
  - Последовательность выполнения действий в разных потоках может привести к неожиданным результатам.
  - Параллельный доступ к общим ресурсам без должной синхронизации может вызвать гонки данных (race conditions) и привести к неправильному поведению программы.
  - Взаимные блокировки и неравномерное распределение ресурсов между потоками могут снижать производительность и приводить к ошибкам.

* Синхронизация потоков:
  - Синхронизация в Java предоставляет механизмы для упорядочивания доступа потоков к общим ресурсам.
  - Ключевое слово synchronized используется для определения блоков кода или методов, которые должны быть защищены от одновременного доступа нескольких потоков.
    - Методы синхронизации:
      1. Модификатор synchronized для методов
         public synchronized void method() {
         // Тело метода
         }
        Когда поток вызывает синхронизированный метод, он захватывает монитор объекта (или класса, если метод статический).
         2. Синхронизированный блок внутри методов:
            public void method() {
              synchronized(this) {
              // Тело синхронизированного блока
              }
            }
         Синхронизированный блок позволяет уточнить объект, монитор которого будет использован для блокировки.

* Примеры синхронизации
  - Проблема синхронизации счётчика (см. Task2 good/fail)
    - Рассмотрим проблему, когда несколько потоков инкрементируют одну и ту же переменную. 
    - Без синхронизации конечное значение переменной будет непредсказуемым из-за race conditions.
  - Синхронизация с использованием synchronized
    - Добавление synchronized к методу increaseCounter гарантирует, что каждый поток будет увеличивать счетчик последовательно, обеспечивая правильный итоговый результат.
  - Избегание блокировок (Deadlocks)
    - Важно проектировать многопоточные приложения таким образом, чтобы избежать взаимных блокировок, когда два или более потоков ждут ресурсы, захваченные друг другом, создавая тем самым состояние вечного ожидания.
  - Рекомендации по синхронизации
    - Используйте синхронизацию экономно, чтобы не снизить производительность приложения.
    - При проектировании многопоточных приложений всегда учитывайте возможность возникновения состояний гонки, взаимных блокировок и других проблем многопоточности.
    - Изучайте и используйте высокоуровневые абстракции и утилиты для многопоточности из пакета java.util.concurrent, которые могут помочь упростить разработку многопоточных приложений и сделать ее более надежной.

### Lesson 1: Notes
* Homework: show the work via pull request from fork to main
* Ultimate Version of Java will be needed a few times, but the teacher will warn us when - it can be procured via coupons or free trial
* changing SDK language:
  * Project Structure -> SDK, Language Level
  * let the project recompile! Note the progress bar down below

### Lesson 1: Consultation
* Github and IDEA

